/* Exercise 03 (versions A, B, C, and D)
I/O: Blocking, non-blocking, multiplexed, asynchronous
------------------------------------------------------

A parent process P generates two children processes C1 and C2.
C1 and P communicate through a pipe p1, and C2 and P communicate
through a pipe p2.
- Process C1:
  every WAIT_TIME_1 second generates a string of STR_SIZE small alphabetic
  letters at most (i.e., from 1 to STR_SIZE letters) and writes the string
  into pipe p1.
  Overall, C1 generates and writes on pipe p1, STR_NUM strings of variable length.
- Process C2:
  does the same things done by C1, but it waits for WAIT_TIME_2
  seconds, and it writes the strings into pipe p2.
- Process P:
  reads the strings coming from the two pipes (p1 and p2), converts
  them in capital letters and displays them on standard output.

Note that:
- WAIT_TIME_1, WAIT_TIME_2, STR_NUM, and STR_SIZE are predefined
  (constant or user-defined) values.
- Strings are randomly generated (composed by only small alphabetic
  letters) of variable length.

Write four versions of the program:

A. Using blocking I/O system calls.
B. Using non-blocking I/O system calls.
C. Using multiplexing I/O.
D. Using asynchronous I/O.

Analyze and compare the outputs generated by the different versions of
the program. 

Suggestion
----------

Processes C1 and C2 write strings of variable *length* on pipes p1 and
p2, respectively.
To let the parent process P read these strings "synchronously", it is
better to use the following simple communication protocol:
- C1 and C2, before writing the string onto the pipe, write its length,
  i.e., a single integer value.
- P reads the integer value n, and then it reads exactly n characters
  (thus, it synchronizes its reading operation with the writing operation
  on the other end of the pipe).
The alternative would be to read from the pipe character-by-character
until finding the termination character of each string ('\0'). */

// compile with -lrt


#include <iostream>
#include <random>
#include <memory>
#include <chrono>
#include <thread>
#include <unistd.h>
#include <sys/wait.h>
#include <aio.h>

#define WAIT_TIME_1 1
#define WAIT_TIME_2 2
#define STR_SIZE 32
#define STR_NUM 5


using namespace std;

void child(int id, int *fd) {
    random_device rd;
    mt19937 mt(rd());
    uniform_int_distribution<unsigned int>dist(1, STR_SIZE);

    close(fd[0]);

    int wait_time = (id==1 ? WAIT_TIME_1 : WAIT_TIME_2);

    for (int t=0; t< STR_NUM; ++t) {
        int dim = dist(mt);
        unique_ptr<char[]> str(new char[dim+1]);


        for (int i=0; i<dim; ++i)
            str[i]='a'+dist(mt)%26;

        str[dim] = '\0';

        cout << "Child " << id << " writes " << str.get() << " (" << dim << ")" << endl;

        write(fd[1], &dim, sizeof(int));
        write(fd[1], str.get(), dim);

        this_thread::sleep_for(chrono::seconds(wait_time));
    }
    close(fd[1]);
    return;
}

void my_read1(int);
void my_read2(int);

int fd1[2], fd2[2];
bool f1, f2;
int t1, t2;
int n1, n2;

int main(void) {
    pipe(fd1);
    pipe(fd2);

    signal (SIGUSR1, my_read1);
    signal (SIGUSR2, my_read2);

    pid_t ret = fork();

    if (!ret) { //first child
        child(1, fd1);
    }
    else {
        ret = fork();
        if (!ret) { //second child
            child(2, fd2);
        }
        else
        {
            close(fd1[1]);
            close(fd2[1]);

            struct aiocb aios1, aios2;
            aios1.aio_fildes = fd1[0];
            aios1.aio_offset = 0;
            aios1.aio_buf = &n1;
            aios1.aio_nbytes = sizeof (int);
            aios1.aio_reqprio = 0;
            aios1.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
            aios1.aio_sigevent.sigev_signo = SIGUSR1;

            aios2.aio_fildes = fd2[0];
            aios2.aio_offset = 0;
            aios2.aio_buf = &n2;
            aios2.aio_nbytes = sizeof (int);
            aios2.aio_reqprio = 0;
            aios2.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
            aios2.aio_sigevent.sigev_signo = SIGUSR2;

            t1 = t2 = 0;
            f1 = f2 = true;

            while(t1<STR_NUM || t2<STR_NUM) {
                if (t1<STR_NUM && f1) {
                    aio_read(&aios1);
                    f1 = false;
                }
                if (t2<STR_NUM && f2) {
                    aio_read(&aios2);
                    f2 = false;
                }
                pause();
            }
        }
    }
    return 0;

}

void my_read1 (int sig) {
    unique_ptr<char[]> str(new char[n1+1]);
    read (fd1[0], str.get(), n1);
    str[n1] = '\0';
    cout << "Parent reads from child 1: " << str.get() << " (" << n1 << ")" << endl;
    f1 = true;
    ++t1;
    return;
}

void my_read2 (int sig) {
    unique_ptr<char[]> str(new char[n2+1]);
    read (fd2[0], str.get(), n2);
    str[n2] = '\0';
    cout << "Parent reads from child 2: " << str.get() << " (" << n2 << ")" << endl;
    f2 = true;
    ++t2;
    return;
}
